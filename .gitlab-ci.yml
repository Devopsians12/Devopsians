# -----------------------------------------------
# Devopsians â€“ GitLab CI/CD Pipeline (Kubernetes/EKS)
# -----------------------------------------------

stages:
  - prepare
  - test
  - build
  - docker
  - deploy

# Trigger on every commit to main branch
workflow:
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'
      when: always
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'
      when: always

# -----------------------------------------------
# GLOBAL NODE TEMPLATE
# -----------------------------------------------
.default_node: &default_node
  image: node:20-alpine
  cache:
    key: "${CI_COMMIT_REF_SLUG}-node-cache"
    paths:
      - frontend/node_modules/
      - backend/node_modules/
  before_script:
    - node -v
    - npm -v

# -----------------------------------------------
# INSTALL DEPENDENCIES
# -----------------------------------------------
prepare:
  stage: prepare
  <<: *default_node
  script:
    - npm install --workspaces
    - npm install --prefix backend
    - npm install --prefix frontend
  artifacts:
    expire_in: 1h
    paths:
      - frontend/node_modules
      - backend/node_modules

# -----------------------------------------------
# TEST PLACEHOLDER
# -----------------------------------------------
test:
  stage: test
  <<: *default_node
  needs: ["prepare"]
  script:
    - echo "No tests defined yet. Skipping."

# -----------------------------------------------
# BUILD FRONTEND (Vite) - Using relative API URL
# -----------------------------------------------
build:
  stage: build
  <<: *default_node
  needs: ["prepare"]
  script:
    - export VITE_API_URL=/
    - cd frontend && npm run build
  artifacts:
    expire_in: 1 day
    paths:
      - frontend/dist

# -----------------------------------------------
# DOCKER BUILD & PUSH
# -----------------------------------------------
docker:
  stage: docker
  image: docker:24.0.7
  services:
    - name: docker:24.0.7-dind
      command: ["--tls=false"]
  needs: ["build"]
  before_script:
    - apk add --no-cache bash git
    - docker version
    - echo "$DOCKERHUB_PASSWORD" | docker login -u "$DOCKERHUB_USERNAME" --password-stdin
  script:
    # Use commit SHA as tag
    - export IMAGE_TAG=${CI_COMMIT_SHORT_SHA}
    - echo "Building with IMAGE_TAG=$IMAGE_TAG"

    # Build backend
    - echo "Building backend..."
    - docker build -t "${DOCKERHUB_USERNAME}/devopsians-backend:${IMAGE_TAG}" -t "${DOCKERHUB_USERNAME}/devopsians-backend:latest" -f backend/Dockerfile .

    # Build frontend with relative API URL
    - echo "Building frontend with VITE_API_URL=/ ..."
    - docker build --build-arg VITE_API_URL=/ -t "${DOCKERHUB_USERNAME}/devopsians-frontend:${IMAGE_TAG}" -t "${DOCKERHUB_USERNAME}/devopsians-frontend:latest" -f frontend/Dockerfile .

    # Push all tags
    - echo "Pushing images..."
    - docker push "${DOCKERHUB_USERNAME}/devopsians-backend:${IMAGE_TAG}"
    - docker push "${DOCKERHUB_USERNAME}/devopsians-backend:latest"
    - docker push "${DOCKERHUB_USERNAME}/devopsians-frontend:${IMAGE_TAG}"
    - docker push "${DOCKERHUB_USERNAME}/devopsians-frontend:latest"
    
    - echo "Images pushed successfully!"
    - echo "Backend: ${DOCKERHUB_USERNAME}/devopsians-backend:latest"
    - echo "Frontend: ${DOCKERHUB_USERNAME}/devopsians-frontend:latest"
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'
      when: always

# -----------------------------------------------
# DEPLOYMENT TO EKS (Using Your Scripts)
# -----------------------------------------------
deploy:
  stage: deploy
  image: alpine:latest
  needs: ["docker"]
  before_script:
    # Install required tools
    - apk add --no-cache curl bash aws-cli
    
    # Install kubectl
    - curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
    - chmod +x kubectl
    - mv kubectl /usr/local/bin/
    - kubectl version --client
    
    # Configure AWS credentials
    - aws configure set aws_access_key_id $AWS_ACCESS_KEY_ID
    - aws configure set aws_secret_access_key $AWS_SECRET_ACCESS_KEY
    - aws configure set region $AWS_REGION
    
    # Connect to EKS cluster
    - aws eks update-kubeconfig --name $EKS_CLUSTER_NAME --region $AWS_REGION
    
    # Verify connection
    - echo "Verifying cluster connection..."
    - kubectl get nodes
    - kubectl get namespaces
    
    # Make scripts executable
    - chmod +x k8s/scripts/*.sh
  script:
    - echo "========================================================"
    - echo "ðŸš€ Deploying Devopsians to EKS"
    - echo "========================================================"
    - echo "Cluster: $EKS_CLUSTER_NAME"
    - echo "Region: $AWS_REGION"
    - echo "Static IP: $STATIC_IP"
    - echo "Commit: $CI_COMMIT_SHORT_SHA"
    - echo ""
    
    # Update backend secret with latest MONGO_URL
    - echo "ðŸ“ Updating backend secret..."
    - |
      kubectl create secret generic backend-secret \
        --from-literal=MONGO_URL="$MONGO_URL" \
        --from-literal=FRONTEND_URL="https://$STATIC_IP" \
        --dry-run=client -o yaml | kubectl apply -f - -n devopsians
    
    # Run the full deployment script
    - echo "ðŸš€ Running full deployment..."
    - cd k8s/scripts
    - ./full-deploy.sh
    
    # Show final status
    - echo ""
    - echo "========================================================"
    - echo "âœ… Deployment Complete!"
    - echo "========================================================"
    - kubectl get pods -n devopsians -o wide
    - kubectl get svc -n devopsians
    - kubectl get ingress -n devopsians
    
    # Health check
    - echo ""
    - echo "ðŸ” Running health check..."
    - sleep 15
    - curl -I --connect-timeout 10 http://$STATIC_IP || echo "âš ï¸  Warning: Health check failed (may take a few minutes to be ready)"
    
    # Final message
    - echo ""
    - echo "ðŸŽ¯ Application URL: https://$STATIC_IP"
    - echo "ðŸ“Š Grafana: https://$STATIC_IP/grafana (if monitoring installed)"
    - echo "ðŸ“ Commit: $CI_COMMIT_SHORT_SHA"
  environment:
    name: production
    url: https://$STATIC_IP
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'
      when: always
  allow_failure: false
